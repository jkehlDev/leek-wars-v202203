/**
 * SORT_MAX_TARGETS
 * SORT_MAX_EFFECT_VALUE
 * SORT_MIN_CAST_DISTANCE
 * SORT_SAFER_CAST_CELL
 * SORT_UNSAFER_CAST_CELL
 * SORT_SAFER_TARGET_CELL
 * SORT_UNSAFER_TARGET_CELL
 * */
global launch_sorters = {
	_isEqual: function(launch1, launch2) {
		return 0;
	},
	_sort: function(launch_lst, priorities) {
		return arraySort(launch_lst, function(launch1, launch2) {
			return priorities(launch1, launch2)
		});
	},
	SORT_MAX_TARGETS: function(next) {
		return function(launch1, launch2) {
			return (launch1.countLeeks > launch2.countLeeks ? -1 :
				(launch1.countLeeks < launch2.countLeeks ? 1 :
					next(launch1, launch2)));
		}
	},
	SORT_MIN_CAST_DISTANCE: function(next) {
		return function(launch1, launch2) {
			return (launch1.cast_cell_distance > launch2.cast_cell_distance ? 1 :
				(launch1.cast_cell_distance < launch2.cast_cell_distance ? -1 :
					next(launch1, launch2)));
		}
	},
	SORT_MAX_EFFECT_VALUE: function(next) {
		return function(launch1, launch2) {
			var compare = compareToolEffectsValueByEffectType(launch1.effects_value, launch2.effects_value);
			return compare !== 0 ? compare : next(launch1, launch2);
		}
	},
	SORT_SAFER_CAST_CELL: function(next) {
		return function(launch1, launch2) {
			var compare = launch1.cast_cell_data.compareEnemiesSumLife(launch2.cast_cell_data);
			return compare !== 0 ? compare : next(launch1, launch2);
		}
	},
	SORT_SAFER_TARGET_CELL: function(next) {
		return function(launch1, launch2) {
			var compare = launch1.target_cell_data.compareEnemiesSumLife(launch2.target_cell_data);
			return compare !== 0 ? compare : next(launch1, launch2);
		}
	}
	SORT_UNSAFER_CAST_CELL: function(next) {
		return function(launch1, launch2) {
			var compare = launch1.cast_cell_data.compareEnemiesSumLife(launch2.cast_cell_data);
			return compare !== 0 ? -compare : next(launch1, launch2);
		}
	},
	SORT_UNSAFER_TARGET_CELL: function(next) {
		return function(launch1, launch2) {
			var compare = launch1.target_cell_data.compareEnemiesSumLife(launch2.target_cell_data);
			return compare !== 0 ? -compare : next(launch1, launch2);
		}
	}
	SORT_MIN_TARGET_DISTANCE_TO: function(_target_cell) {
		return function(next) {
			return function(launch1, launch2) {
				var dist_1 = getPathLength(_target_cell, launch1.target_cell_id);
				dist_1 = dist_1 === null ? getCellDistance(_target_cell, launch1.target_cell_id) : dist_1;
				var dist_2 = getPathLength(_target_cell, launch2.target_cell_id);
				dist_2 = dist_2 === null ? getCellDistance(_target_cell, launch2.target_cell_id) : dist_2;
				var _compareRateSumLife = GBL_radar_tactic_map_by_cells[launch1.target_cell_id].compareRateSumLife(GBL_radar_tactic_map_by_cells[launch2.target_cell_id]);
				return ((dist_1 > dist_2) ? 1 :
					((dist_1 < dist_2) ? -1 :
						(_compareRateSumLife !== 0 ? _compareRateSumLife :
							next(launch1, launch2))));
			}
		}
	},
};

/**
 * CAST_ON_TARGET
 * CAST_AROUND
 * CAST_PUSH
 * */
global launch_resolvers = {
	CAST_ON_TARGET: "CAST_ON_TARGET",
	CAST_AROUND: "CAST_AROUND",
	CAST_PUSH: "CAST_PUSH",
	_resolve: [
		"CAST_PUSH": function(launch_contract, tool_id, needLos, tool_isWeapon, isLineEffect) {
			var launch_lst = [];
			var leek, resolved_cast_map, caster_cells_ids, caster_cell_id, launch_area_map, touch_map, target_leek_cell_id, select_target_area_map;
			var caster = getLeekById(launch_contract.caster_leek_id);
			for (leek in launch_contract.target_leeks_ids) {
				if (leek.leek_id !== launch_contract.caster_leek_id) {
					target_leek_cell_id = getLeekById(leek.leek_id).leek_cell;
					resolved_cast_map = intersection(resolveAreaTemplateOnCell(AREA_PUNCH.select_cast_area, target_leek_cell_id, true).map,
						launch_contract.caster_pathmap.mapAll,
						launch_contract.caster_pathmap.coordinates_min.line,
						launch_contract.caster_pathmap.coordinates_max.line);
					caster_cells_ids = convertBinaryMapToCellIdMap(resolved_cast_map,
						launch_contract.caster_pathmap.coordinates_min,
						launch_contract.caster_pathmap.coordinates_max);
					caster_cells_ids = arrayFilter(caster_cells_ids, function(_cell) {
						return getPathLength(caster.leek_cell, _cell.cell_id) <= caster.leek_mp;
					});

					for (caster_cell_id in caster_cells_ids) {
						// resolve intersection between launch area and target area 
						launch_area_map = resolveAreaTemplateOnCell(AREA_PUNCH.select_target_area, caster_cell_id.cell_id, true);
						select_target_area_map = resolveAreaTemplateOnCell(AREA_PUNCH.select_target_area, target_leek_cell_id, true);
						touch_map = {
							map: intersection(
								select_target_area_map.map,
								launch_area_map.map,
								select_target_area_map.coordinates_min.line,
								select_target_area_map.coordinates_max.line),
							coordinates_min: select_target_area_map.coordinates_min,
							coordinates_max: select_target_area_map.coordinates_max
						};
						//markBinaryMap(touch_map, COLOR_RED);
						launch_lst = addLaunchForLineEffect(launch_lst, tool_id, needLos, tool_isWeapon, isLineEffect, touch_map, caster_cell_id.cell_id, launch_contract.caster_leek_id);
					}
				}
			}
			return launch_lst;
		},
		"CAST_AROUND": function(launch_contract, tool_id, needLos, tool_isWeapon, isLineEffect) {
			var launch_lst = [];
			var caster_cell_id = getLeekById(launch_contract.caster_leek_id).leek_cell;
			var target_area_map = resolveToolLaunchAreaTemplateOnCell(tool_id, caster_cell_id, true);
			if (tool_id === CHIP_JUMP) {
				target_area_map.map = soustraire(
					target_area_map.map,
					GBL_obstacles_map_binary_with_leek.map,
					target_area_map.coordinates_min.line,
					target_area_map.coordinates_max.line
				);
			}
			if (isLineEffect) {
				launch_lst = addLaunchForLineEffect(
					launch_lst,
					tool_id,
					needLos,
					tool_isWeapon,
					isLineEffect,
					target_area_map,
					caster_cell_id,
					launch_contract.caster_leek_id
				);
			} else {
				launch_lst = addLaunch(
					launch_lst,
					tool_id,
					needLos,
					tool_isWeapon,
					isLineEffect,
					target_area_map,
					caster_cell_id,
					launch_contract.caster_leek_id
				);
			}
			return launch_lst;
		},
		"CAST_ON_TARGET": function(launch_contract, tool_id, needLos, tool_isWeapon, isLineEffect) {
			var leek;
			var launch_lst = [];
			var target_area_by_leek_id = [];
			for (leek in launch_contract.target_leeks_ids) {
				target_area_by_leek_id[leek.leek_id] = resolveToolEffectAreaTemplateOnCell(tool_id, getLeekById(leek.leek_id).leek_cell, true);
				if (tool_id === CHIP_JUMP) {
					target_area_by_leek_id[leek.leek_id].map = soustraire(
						target_area_by_leek_id[leek.leek_id].map,
						GBL_obstacles_map_binary_with_leek.map,
						target_area_by_leek_id[leek.leek_id].coordinates_min.line,
						target_area_by_leek_id[leek.leek_id].coordinates_max.line
					);
				}
			}
			var caster_cells_ids = convertBinaryMapToCellIdMap(launch_contract.caster_pathmap.mapAll,
				launch_contract.caster_pathmap.coordinates_min,
				launch_contract.caster_pathmap.coordinates_max);
			var caster = getLeekById(launch_contract.caster_leek_id);
			caster_cells_ids = arrayFilter(caster_cells_ids, function(_cell) {
				return getPathLength(caster.leek_cell, _cell.cell_id) <= caster.leek_mp;
			});
			var caster_cell_id, launch_area_map, touch_map, leeks_in_effect_area_by_target_id;
			for (caster_cell_id in caster_cells_ids) {
				launch_area_map = resolveToolLaunchAreaTemplateOnCell(tool_id, caster_cell_id.cell_id, true);
				for (leek in launch_contract.target_leeks_ids) {
					touch_map = {
						map: intersection(launch_area_map.map,
							target_area_by_leek_id[leek.leek_id].map,
							target_area_by_leek_id[leek.leek_id].coordinates_min.line,
							target_area_by_leek_id[leek.leek_id].coordinates_max.line),
						coordinates_min: target_area_by_leek_id[leek.leek_id].coordinates_min,
						coordinates_max: target_area_by_leek_id[leek.leek_id].coordinates_max
					};
					if (binaryMapNotEmpty(touch_map.map, touch_map.coordinates_min.line, touch_map.coordinates_max.line)) {
						if (isLineEffect) {
							launch_lst = addLaunchForLineEffect(
								launch_lst,
								tool_id,
								needLos,
								tool_isWeapon,
								isLineEffect,
								touch_map,
								caster_cell_id.cell_id,
								launch_contract.caster_leek_id
							);
						} else {
							launch_lst = addLaunch(
								launch_lst,
								tool_id,
								needLos,
								tool_isWeapon,
								isLineEffect,
								touch_map,
								caster_cell_id.cell_id,
								launch_contract.caster_leek_id
							);
						}
					}
				}
			}
			return launch_lst;
		}
	]
};
//leeks
//caster_cells_ids
//target_cell_id
//tool_id
//caster_leek_id
//effect_area_cells
/**
 * NO_EFFECT_LESS_ON : function(effect_type, leek_type, value)
 * NO_NULL_EFFECT_OF : function(effects) - effect : [ type, ... ]
 * NO_LESS_EFFECT_OF : function(effects) - effect : [ { type, value }, ... ]
 * _resolve_filters  : function(_filters, _launchs)
 * */
global GBL_launch_filters_after_linearize = {
	// effect : [ effect_type, ... ]
	NO_LESS_EFFECT_OF: function(effects) {
		var _filterEffect = arrayFoldRight(effects, function(_effect, _agregate) {
			return function(_launch) {
				var launch_effect = arrayFind(_launch.effects_value, function(_launch_effect) {
					return _launch_effect.effect_type === _effect.type;
				});

				return _agregate(_launch) || (launch_effect !== null && launch_effect.value > _effect.value);
			}
		}, _filter_false);
		return function(_next) {
			return function(_launch) {
				return _next(_launch) && _filterEffect(_launch);
			}
		}
	},
	// effect : [ effect_type, ... ]
	NO_NULL_EFFECT_OF: function(effects) {
		var _filterEffect = arrayFoldRight(effects, function(_effect, _agregate) {
			return function(_launch) {
				var launch_effect = arrayFind(_launch.effects_value, function(_launch_effect) {
					return _launch_effect.effect_type === _effect;
				});

				return _agregate(_launch) || (launch_effect !== null && launch_effect.value > 0);
			}
		}, _filter_false);
		return function(_next) {
			return function(_launch) {
				return _next(_launch) && _filterEffect(_launch);
			}
		}
	},
	NO_EFFECT_LESS_ON: function(effect_type, leek_type, valueMin) {
		var _filterEffect = function(_launch) {
			var _target_leek_ids = arrayFilter(_launch.touched_leeks, function(_leek_id) {
				return (leek_type & getLeekTypeById(_leek_id)) !== 0;
			});
			var _caster = getLeekById(_launch.caster_leek_id);
			var _effect = arrayFind(getToolById(_launch.tool_id).tool_effects, function(_tool_effect) {
				return _tool_effect.type === effect_type;
			});

			return _effect === null ? false : (arrayFoldLeft(_target_leek_ids, function(_sum, target_leek_id) {
				return _sum + evaluateEffect(_caster, getLeekById(target_leek_id), _effect, _launch.tool_id, _launch.countLeeks);
			}, 0) > valueMin);
		}
		return function(_next) {
			return function(_launch) {
				return _next(_launch) && _filterEffect(_launch);
			}
		}
	},
	NO_EFFECTS_LESS_ON: function(_params) {
		var _filterEffect = arrayFoldLeft(_params, function(_agregate, _filter) {
			var _filterTmp = function(_launch) {
				var _target_leek_ids = arrayFilter(_launch.touched_leeks, function(_leek_id) {
					return (_filter.leek_type & getLeekTypeById(_leek_id)) !== 0;
				});
				var _caster = getLeekById(_launch.caster_leek_id);
				var _effect = arrayFind(getToolById(_launch.tool_id).tool_effects, function(_tool_effect) {
					return _tool_effect.type === _filter.effect_type;
				});

				return _effect === null ? false : (arrayFoldLeft(_target_leek_ids, function(_sum, target_leek_id) {
					return _sum + evaluateEffect(_caster, getLeekById(target_leek_id), _effect, _launch.tool_id, _launch.countLeeks);
				}, 0) > _filter.valueMin);
			}
			return function(_launch) {
				return _agregate(_launch) || _filterTmp(_launch);
			}
		}, _filter_false);

		return function(_next) {
			return function(_launch) {
				return _next(_launch) && _filterEffect(_launch);
			}
		}
	},
	PRIORITY_TARGET: function(_leeks_states, _filter) {
		var _priorityTargets = arrayFilter(_leeks_states, _filter);
		var _filterLaunchs;
		if (count(_priorityTargets) > 0) {
			_filterLaunchs = function(_launch) {
				return arrayInclude(_launch.touched_leeks, function(_touched_leek_id) {
					return arrayInclude(_priorityTargets, function(_priority_leek) {
						return _touched_leek_id === _priority_leek.leek_id
					});
				});
			}
		} else {
			_filterLaunchs = function(_launch) {
				return false;
			}
		}
		return function(_next) {
			return function(_launch) {
				return _next(_launch) && _filterLaunchs(_launch);
			}
		};
	}
	_resolve_filters: function(_filters, _launchs) {
		var resolvedFilters = arrayFoldRight(_filters, function(_filter, _agregate) {
			return _filter(_agregate);
		}, _filter_true);
		return arrayFilter(_launchs, resolvedFilters);
	}
}
/**
 * TARGET_ONLY_ALLIES
 * TARGET_ONLY_ENEMIES
 * TARGET_ONLY_CASTER
 * TARGET_NOT_CASTER
 * TARGET_ONLY_SUMMONS
 * TARGET_NOT_SUMMONS
 * TARGET_CASTER_AND_ENEMIES
 * TARGET_NO_ONE
 * TARGET_HAS_ONE_OF_EFFECTS: function(effects, minLeftTurn) - effects : [effect, ...] - minLeftTurn : min (strict) turns left for effect on target
 * TARGET_AT_LEAST_X_TYPE_OF_LEEKS : function(params) - params : [ { typesOf : binary compose of leek type, count : number at least }, .. ]
 * TARGET_ONLY_TYPE_OF_LEEKS : function(typesOf) - typesOf : binary compose of leek type
 * _resolve_filters : function(_filters, _launchs)
 * */
global GBL_launch_filters_before_linearize = {
	TARGET_ONLY_ALLIES: function(_next) {
		return function(launch) {
			return _next(launch) && !arrayInclude(launch.leeks, function(leek_id) {
				return getLeekById(leek_id).leek_isEnemy;
			});
		}
	},
	TARGET_ONLY_ENEMIES: function(_next) {
		return function(launch) {
			return _next(launch) && !arrayInclude(launch.leeks, function(leek_id) {
				return getLeekById(leek_id).leek_isAlly;
			});
		}
	},
	TARGET_ONLY_CASTER: function(_next) {
		return function(launch) {
			return _next(launch) && !arrayInclude(launch.leeks, function(leek_id) {
				return !getLeekById(leek_id).leek_isCaster;
			});
		}
	},
	TARGET_NOT_CASTER: function(_next) {
		return function(launch) {
			return _next(launch) && !arrayInclude(launch.leeks, function(leek_id) {
				return getLeekById(leek_id).leek_isCaster;
			});
		}
	},
	TARGET_ONLY_SUMMONS: function(_next) {
		return function(launch) {
			return _next(launch) && !arrayInclude(launch.leeks, function(leek_id) {
				return !getLeekById(leek_id).leek_isSummon;
			});
		}
	},
	TARGET_NOT_SUMMONS: function(_next) {
		return function(launch) {
			return _next(launch) && !arrayInclude(launch.leeks, function(leek_id) {
				return getLeekById(leek_id).leek_isSummon;
			});
		}
	},
	TARGET_CASTER_AND_ENEMIES: function(_next) {
		return function(launch) {
			return _next(launch) && !arrayInclude(launch.leeks, function(leek_id) {
				return !getLeekById(leek_id).leek_isCaster && !getLeekById(leek_id).leek_isEnemy;
			});
		}
	},
	TARGET_NO_ONE: function(_next) {
		return function(launch) {
			return _next(launch) && count(launch.leeks) === 0;
		}
	},
	TARGET_NOT_EMPTY: function(_next) {
		return function(launch) {
			return _next(launch) && count(launch.leeks) > 0;
		}
	},
	TARGET_HAS_ONE_OF_EFFECTS: function(effects, minLeftTurn) {
		return function(_next) {
			return function(launch) {
				return _next(launch) && arrayInclude(launch.leeks, function(_leek_id) {
					return leekHasOneOfEffects(effects, getLeekById(_leek_id), minLeftTurn);
				});
			}
		}
	},
	TARGET_AT_LEAST_X_TYPE_OF_LEEKS: function(params) {
		var _filterByLeek = arrayFoldRight(params, function(_param, _agregate) {
			return function(_launch) {
				return _agregate(_launch) && count(arrayFilter(_launch.leeks, function(leek_id) {
					return (getLeekTypeById(leek_id) & _param.typesOf) !== 0;
				})) >= _param.count;
			}
		}, _filter_true);
		return function(_next) {
			return function(launch) {
				return _next(launch) && _filterByLeek(launch);
			}
		}
	},
	TARGET_ONLY_TYPE_OF_LEEKS: function(typesOf) {
		return function(_next) {
			return function(launch) {
				return _next(launch) && !arrayInclude(launch.leeks, function(leek_id) {
					return (getLeekTypeById(leek_id) & typesOf) === 0;
				});
			}
		}
	},
	_resolve_filters: function(_filters, _launchs) {
		var resolvedFilters = arrayFoldRight(_filters, function(_filter, _agregate) {
			return _filter(_agregate);
		}, _filter_true);
		return arrayFilter(_launchs, resolvedFilters);
	}
}


/**
 * Add Launch (default) - Target cell is only parameter for resolving leeks effected by cast
 * */
function addLaunch(launch_lst, tool_id, needLos, tool_isWeapon, isLineEffect, touch_map, caster_cell_id, caster_leek_id) {
	var target_cells_ids = convertBinaryMapToCellIdMap(touch_map.map,
		touch_map.coordinates_min,
		touch_map.coordinates_max);
	var effect_tool_map;
	if (needLos) {
		for (var target_cell_id in target_cells_ids) {
			if (lineOfSight(caster_cell_id, target_cell_id.cell_id)) {
				if (launch_lst[target_cell_id.cell_id] === null) {
					launch_lst[target_cell_id.cell_id] = {
						leeks: resolveLeeksTouchedByLaunch(tool_id, tool_isWeapon, isLineEffect, target_cell_id.cell_id, caster_cell_id, caster_leek_id),
						caster_cells_ids: [caster_cell_id: caster_cell_id],
						target_cell_id: target_cell_id.cell_id,
						tool_id: tool_id,
						caster_leek_id: caster_leek_id
					};

				} else {
					launch_lst[target_cell_id.cell_id].caster_cells_ids[caster_cell_id] = caster_cell_id;
				}
			}
		}
	} else {
		for (var target_cell_id in target_cells_ids) {
			if (launch_lst[target_cell_id.cell_id] === null) {
				launch_lst[target_cell_id.cell_id] = {
					leeks: resolveLeeksTouchedByLaunch(tool_id, tool_isWeapon, isLineEffect, target_cell_id.cell_id, caster_cell_id, caster_leek_id),
					caster_cells_ids: [caster_cell_id: caster_cell_id],
					target_cell_id: target_cell_id.cell_id,
					tool_id: tool_id,
					caster_leek_id: caster_leek_id
				};
			} else {
				launch_lst[target_cell_id.cell_id].caster_cells_ids[caster_cell_id] = caster_cell_id;
			}
		}
	}
	return launch_lst;
}

/**
 * Add Launch for line effect tool - Cast and target cell are parameters for resolving leeks effected by cast
 * */
function addLaunchForLineEffect(launch_lst, tool_id, needLos, tool_isWeapon, isLineEffect, touch_map, caster_cell_id, caster_leek_id) {
	var target_cells_ids = convertBinaryMapToCellIdMap(touch_map.map,
		touch_map.coordinates_min,
		touch_map.coordinates_max);
	var launch_map_cells_ids = resolveToolLaunchAreaTemplateOnCell(tool_id, caster_cell_id, false);
	launch_map_cells_ids = convertBinaryMapToCellIdMap(launch_map_cells_ids.map,
		launch_map_cells_ids.coordinates_min,
		launch_map_cells_ids.coordinates_max);
	if (needLos) {
		for (var target_cell_id in target_cells_ids) {

			if (lineOfSight(caster_cell_id, target_cell_id.cell_id)) {
				push(launch_lst, {
					leeks: resolveLeeksTouchedByLaunch(tool_id, tool_isWeapon, isLineEffect, target_cell_id.cell_id, caster_cell_id, caster_leek_id),
					caster_cells_ids: [caster_cell_id: caster_cell_id],
					target_cell_id: target_cell_id.cell_id,
					tool_id: tool_id,
					caster_leek_id: caster_leek_id,
					effect_area_cells: launch_map_cells_ids
				});
			}
		}
	} else {
		for (var target_cell_id in target_cells_ids) {
			push(launch_lst, {
				leeks: resolveLeeksTouchedByLaunch(tool_id, tool_isWeapon, isLineEffect, target_cell_id.cell_id, caster_cell_id, caster_leek_id),
				caster_cells_ids: [caster_cell_id: caster_cell_id],
				target_cell_id: target_cell_id.cell_id,
				tool_id: tool_id,
				caster_leek_id: caster_leek_id,
				effect_area_cells: launch_map_cells_ids
			});
		}
	}
	return launch_lst;
}

/**
 * Resolver - resolver wich leek are affected by a launch
 * */
function resolveLeeksTouchedByLaunch(tool_id, tool_isWeapon, isLineEffect, target_cell_id, caster_cell_id, caster_leek_id) {
	var leeks_in_effect_area = [];
	var tool_effects = getToolById(tool_id).tool_effects;
	var caster_leek = getLeekById(caster_leek_id);
	var isEnableEffectOnLeek, effect;
	//console.info(["isLineEffect", isLineEffect, "effect_tool_cells", effect_tool_cells]);
	//console.info(["tool_id : " + tool_id, "target_cell_id : " + target_cell_id, "caster_cell_id : " + caster_cell_id]);
	if (isLineEffect) {
		var effect_tool_cells = tool_isWeapon ? getWeaponEffectiveArea(tool_id,
				target_cell_id,
				caster_cell_id) :
			getChipEffectiveArea(tool_id, target_cell_id, caster_cell_id);
		for (var leek in getAllAliveLeeks()) {
			if (arrayInclude(effect_tool_cells, function(cell_id) {
					return cell_id === leek.leek_cell;
				})) {
				isEnableEffectOnLeek = false;
				for (effect in tool_effects) {
					if (canApplyEffectOnLeek(caster_leek, leek, effect, tool_id)) {
						isEnableEffectOnLeek = true;
						break;
					}
				}
				if (isEnableEffectOnLeek) {
					leeks_in_effect_area[leek.leek_id] = leek.leek_id;
				}
			}
		}
		if (arrayInclude(effect_tool_cells, function(cell_id) {
				return cell_id === caster_cell_id
			})) {
			isEnableEffectOnLeek = false;
			for (effect in tool_effects) {
				if (canApplyEffectOnLeek(caster_leek, caster_leek, effect, tool_id)) {
					isEnableEffectOnLeek = true;
					break;
				}
			}
			if (isEnableEffectOnLeek) {
				leeks_in_effect_area[caster_leek_id] = caster_leek_id;
			}
		}
	} else {
		var effect_tool_map = resolveToolEffectAreaTemplateOnCell(tool_id, target_cell_id, true);
		for (var leek in getAllAliveLeeks()) {
			if (binaryMapHasCell(effect_tool_map.map, leek.leek_cell)) {
				isEnableEffectOnLeek = false;
				for (effect in tool_effects) {
					if (canApplyEffectOnLeek(caster_leek, leek, effect, tool_id)) {
						isEnableEffectOnLeek = true;
						break;
					}
				}
				if (isEnableEffectOnLeek) {
					leeks_in_effect_area[leek.leek_id] = leek.leek_id;
				}
			}
		}
		if (binaryMapHasCell(effect_tool_map.map, caster_cell_id)) {
			isEnableEffectOnLeek = false;
			for (effect in tool_effects) {
				if (canApplyEffectOnLeek(caster_leek, caster_leek, effect, tool_id)) {
					isEnableEffectOnLeek = true;
					break;
				}
			}
			if (isEnableEffectOnLeek) {
				leeks_in_effect_area[caster_leek_id] = caster_leek_id;
			}
		}
	}
	return leeks_in_effect_area;
}

/**
 * Linearizer - Launchs list
 * {
 *	touched_leeks,
 *	countLeeks,
 *	caster_leek_id,
 *	cast_cell_id,
 *	cast_cell_distance,
 *	target_cell_id,
 *	tool_id,
 *	effects_value
 * }[]
 * 
 * */
function linearizeLaunchLst(launch_lst) {
	var launch, cast_cell_id, caster_leek, tool, effects_value, countLeeks, effect_by_leek, hasPushEffect;
	var effect, leek;
	var launchs_linearized = [];
	if (count(launch_lst) > 0) {
		tool = getToolById(launch_lst[0].tool_id);
		caster_leek = getLeekById(launch_lst[0].caster_leek_id);
	}
	for (launch in launch_lst) {
		for (cast_cell_id in launch.caster_cells_ids) {
			effects_value = [];
			hasPushEffect = false;
			for (effect in tool.tool_effects) {
				if (effect.type === EFFECT_PUSH) {
					hasPushEffect = true;
				}
				effects_value[effect.type] = {
					effect_type: effect.type,
					value: 0
				};
			}
			countLeeks = count(launch.leeks);
			for (leek in launch.leeks) {
				effect_by_leek = resolveToolEffectsValueByEffectType(
					caster_leek,
					getLeekById(leek),
					launch.tool_id,
					countLeeks);
				for (effect in effect_by_leek) {
					effects_value[effect.effect_type].value += effect_by_leek[effect.effect_type].value;
				}
				if (hasPushEffect) {
					effects_value[EFFECT_PUSH].value += resolvePushEffectValue(cast_cell_id, getLeekById(leek).leek_cell, launch.target_cell_id, launch.effect_area_cells);
				}
			}
			push(launchs_linearized, new LaunchItem(
				clone(launch.leeks, 2),
				countLeeks,
				launch.caster_leek_id,
				cast_cell_id,
				GBL_radar_tactic_map_by_cells[cast_cell_id],
				getPathLength(caster_leek.leek_cell, cast_cell_id),
				launch.target_cell_id,
				GBL_radar_tactic_map_by_cells[launch.target_cell_id],
				launch.tool_id,
				clone(effects_value, 2)
			));
		}
	}
	return launchs_linearized;
}

function compareToolEffectsValueByEffectType(tool_effects_value__1, tool_effects_value__2) {
	var effects_type = arrayMap(tool_effects_value__1, function(tool_effect_value) {
		return tool_effect_value.effect_type;
	});
	effects_type = arraySort(effects_type, function(type1, type2) {
		return type1 < type2 ? -1 : (type1 > type2 ? 1 : 0)
	});
	var value1, value2;
	for (var effect_type in effects_type) {
		value1 = tool_effects_value__1[effect_type].value;
		value2 = tool_effects_value__2[effect_type].value;
		if (value1 > value2) {
			return -1;
		} else if (value1 < value2) {
			return 1;
		}
	};
	return 0;
}



/**
 * Resolver - Resolve tool effects value by effect type
 * { effect_type, value }[effect_type]
 * */
function resolveToolEffectsValueByEffectType(caster, target, tool_id, targets_count) {
	var effects_value = [];
	var tool = getToolById(tool_id);
	var tool_effect, tool_effect_agregated, countSameEffect, i;
	for (tool_effect in tool.tool_effects) {
		if (EvalEffectValue[tool_effect.type] !== null) {
			effects_value[tool_effect.type] = {
				effect_type: tool_effect.type,
				value: evaluateEffect(caster, target, tool_effect, tool.tool_id, targets_count),
			};
		}
	}
	return effects_value;
}

/**
 * Resolver - Resolve Push effect value as push cells distance
 * */
function resolvePushEffectValue(caster_cell_id, target_leek_cell, target_cell_id, effect_area_cells) {
	var distTargetFromCast = getCellDistance(caster_cell_id, target_cell_id);
	effect_area_cells = arrayFilter(effect_area_cells, function(effect_area_cell) {
		var distFromCast = getCellDistance(caster_cell_id, effect_area_cell.cell_id);
		var distFromLeek = getCellDistance(target_leek_cell, effect_area_cell.cell_id);
		return isOnSameLine(effect_area_cell.cell_id, target_leek_cell) &&
			distFromCast > distFromLeek &&
			distFromLeek <= distTargetFromCast;
	});
	effect_area_cells = arraySort(effect_area_cells, function(effect_area_cell1, effect_area_cell2) {
		var dist1 = getDistance(caster_cell_id, effect_area_cell1.cell_id);
		var dist2 = getDistance(caster_cell_id, effect_area_cell2.cell_id);
		return dist1 < dist2 ? 1 : dist1 > dist2 ? -1 : 0;
	});
	var effect_value = 0;
	for (var effect_area_cell in effect_area_cells) {
		if (effect_area_cell.cell_id === target_leek_cell) {
			return effect_value;
		}
		if (GBL_obstacles_cells[effect_area_cell.cell_id] === null) {
			effect_value = (effect_value === 0) ? getCellDistance(target_leek_cell, effect_area_cell.cell_id) : effect_value;
		} else {
			effect_value = 0;
		}
	}
	return effect_value;
}