// -- --------------------------------------------------------------------------------------------------
function GBL_Resolve_KILL_SHOOT(_tpMalus, _target_cell) {
	var _selectedOptions = _IA_cards['DAMAGE_ZONE'].getOptionsBy(
		[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp - _tpMalus)],
		GBL_sort_toolCardOption_by_cost_dsc, []);
	var _isExecuted = false;
	var _excludeTools = [];
	var _contract, _currentOption, _tool_id, _contract_options;
	while (count(_selectedOptions) > 0 && !_isExecuted) {
		_currentOption = shift(_selectedOptions);
		for (_tool_id in _currentOption._cast_array) {
			if (_tool_id === CHIP_PROTEIN || _tool_id === CHIP_STEROID || _tool_id === CHIP_STRETCHING) {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.ON_ME,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ALLY_CASTER),
					],
					[]);
			} else if (_tool_id === CHIP_DEVIL_STRIKE) {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.TARGET,
					[
						GBL_Contract_filters.HAS_TARGETS_Q2(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON),
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON | LEEK_TYPE_ALLY_CASTER),
						GBL_Contract_filters.EFFECTS_LESSER({
							_target_type_from: LEEK_TYPE_ALLY_CASTER,
							_target_type_to: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE,
							_factor: 2
						}),
						GBL_Contract_filters.EFFECTS_OR([{
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE,
							_minValue: 300,
							_maxValue: 10000
						}]),
					],
					[
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE
						}),
						_target_cell !== null ? GBL_Contract_sorters.DIST_CAST_ASC_TO(_target_cell) : GBL_Contract_sorters.TARGET_SAFEST(),
					]);
			} else {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.TARGET,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON),
						GBL_Contract_filters.HAS_TARGETS_Q2(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON),
						GBL_Contract_filters.EFFECTS_OR([{
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_NOVA_VITALITY,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_LIFE_DAMAGE,
							_minValue: 0,
							_maxValue: 10000
						}, ]),
					],
					[
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON
						}),
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE
						}),
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_NOVA_VITALITY
						}),
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_LIFE_DAMAGE
						}),
						_target_cell !== null ? GBL_Contract_sorters.DIST_CAST_ASC_TO(_target_cell) : GBL_Contract_sorters.TARGET_SAFEST(),
					]);
			}
			_contract_options = FCT_ResolveContractOptions(_contract);
			if (count(_contract_options) > 0) {
				_isExecuted = true;
				shift(_contract_options).use();
			} else {
				_isExecuted = false;
				push(_excludeTools, _tool_id);
				_selectedOptions = _IA_cards['DAMAGE_ZONE'].getOptionsBy(
					[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp - _tpMalus)],
					GBL_sort_toolCardOption_by_cost_dsc, _excludeTools);
				break;
			}
		}
	}

	_selectedOptions = _IA_cards['WEAPONS'].getOptionsBy(
		[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp - _tpMalus)],
		GBL_sort_toolCardOption_by_cost_dsc, []);
	_isExecuted = false;
	_excludeTools = [];
	while (count(_selectedOptions) > 0 && !_isExecuted) {
		_currentOption = shift(_selectedOptions);
		for (_tool_id in _currentOption._cast_array) {
			if (_tool_id === CHIP_PROTEIN || _tool_id === CHIP_STEROID || _tool_id === CHIP_STRETCHING) {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.ON_ME,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ALLY_CASTER),
					],
					[]);
			} else {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.TARGET,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON),
						GBL_Contract_filters.HAS_TARGETS_Q2(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON),
						GBL_Contract_filters.EFFECTS_OR([{
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_NOVA_VITALITY,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_LIFE_DAMAGE,
							_minValue: 0,
							_maxValue: 10000
						}, ]),
					],
					[
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON
						}),
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE
						}),
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_NOVA_VITALITY
						}),
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_LIFE_DAMAGE
						}),
						_target_cell !== null ? GBL_Contract_sorters.DIST_CAST_ASC_TO(_target_cell) : GBL_Contract_sorters.TARGET_SAFEST(),
					]);
			}

			_contract_options = FCT_ResolveContractOptions(_contract);
			if (count(_contract_options) > 0) {
				_isExecuted = true;
				shift(_contract_options).use();
			} else {
				_isExecuted = false;
				push(_excludeTools, _tool_id);
				_selectedOptions = _IA_cards['WEAPONS'].getOptionsBy(
					[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp - _tpMalus)],
					GBL_sort_toolCardOption_by_cost_dsc, _excludeTools);
				break;
			}
		}
	}
}
// -- --------------------------------------------------------------------------------------------------
function GBL_Resolve_DAMAGE_ZONE(_target_cell) {
	var _selectedOptions = _IA_cards['DAMAGE_ZONE'].getOptionsBy(
		[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp)],
		GBL_sort_toolCardOption_by_cost_dsc, []);
	var _isExecuted = false;
	var _excludeTools = [];
	var _contract, _currentOption, _tool_id, _contract_options;
	while (count(_selectedOptions) > 0 && !_isExecuted) {
		_currentOption = shift(_selectedOptions);
		for (_tool_id in _currentOption._cast_array) {
			if (_tool_id === CHIP_PROTEIN || _tool_id === CHIP_STEROID || _tool_id === CHIP_STRETCHING) {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.ON_ME,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ALLY_CASTER),
					],
					[]);
			} else if (_tool_id === CHIP_DEVIL_STRIKE) {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.TARGET,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON | LEEK_TYPE_ALLY_CASTER),
						GBL_Contract_filters.EFFECTS_LESSER({
							_target_type_from: LEEK_TYPE_ALLY_CASTER,
							_target_type_to: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE,
							_factor: 2
						}),
						GBL_Contract_filters.EFFECTS_OR([{
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE,
							_minValue: 300,
							_maxValue: 10000
						}]),
					],
					[
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE
						}),
						_target_cell !== null ? GBL_Contract_sorters.DIST_CAST_ASC_TO(_target_cell) : GBL_Contract_sorters.TARGET_SAFEST(),
					]);

			} else {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.TARGET,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON),
						GBL_Contract_filters.EFFECTS_OR([{
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_NOVA_VITALITY,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_LIFE_DAMAGE,
							_minValue: 0,
							_maxValue: 10000
						}, ]),
					],
					[
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON
						}),
						GBL_Contract_sorters.TARGET_EFFECT_ASC({
							_target_type: LEEK_TYPE_ALLY,
							_effect_type: EFFECT_ABSOLUTE_SHIELD
						}),
						_target_cell !== null ? GBL_Contract_sorters.DIST_CAST_ASC_TO(_target_cell) : GBL_Contract_sorters.TARGET_SAFEST(),
					]);
			}
			_contract_options = FCT_ResolveContractOptions(_contract);
			if (count(_contract_options) > 0) {
				_isExecuted = true;
				shift(_contract_options).use();
			} else {
				_isExecuted = false;
				push(_excludeTools, _tool_id);
				_selectedOptions = _IA_cards['DAMAGE_ZONE'].getOptionsBy(
					[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp)],
					GBL_sort_toolCardOption_by_cost_dsc, _excludeTools);
				break;
			}
		}
	}
}
// -- --------------------------------------------------------------------------------------------------
function GBL_Resolve_WEAPONS(_target_cell) {
	var _selectedOptions = _IA_cards['WEAPONS'].getOptionsBy(
		[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp)],
		GBL_sort_toolCardOption_by_cost_dsc, []);
	var _isExecuted = false;
	var _excludeTools = [];
	var _contract, _currentOption, _tool_id, _contract_options;
	while (count(_selectedOptions) > 0 && !_isExecuted) {
		_currentOption = shift(_selectedOptions);
		for (_tool_id in _currentOption._cast_array) {
			if (_tool_id === CHIP_PROTEIN || _tool_id === CHIP_STEROID || _tool_id === CHIP_STRETCHING) {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.ON_ME,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ALLY_CASTER),
					],
					[]);
			} else {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.TARGET,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON),
						GBL_Contract_filters.EFFECTS_OR([{
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_DAMAGE,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_NOVA_VITALITY,
							_minValue: 0,
							_maxValue: 10000
						}, {
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_LIFE_DAMAGE,
							_minValue: 0,
							_maxValue: 10000
						}, ]),
					],
					[
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON
						}),
						GBL_Contract_sorters.TARGET_EFFECT_ASC({
							_target_type: LEEK_TYPE_ALLY,
							_effect_type: EFFECT_ABSOLUTE_SHIELD
						}),
						_target_cell !== null ? GBL_Contract_sorters.DIST_CAST_ASC_TO(_target_cell) : GBL_Contract_sorters.TARGET_SAFEST(),
					]);
			}

			_contract_options = FCT_ResolveContractOptions(_contract);
			if (count(_contract_options) > 0) {
				_isExecuted = true;
				shift(_contract_options).use();
			} else {
				_isExecuted = false;
				push(_excludeTools, _tool_id);
				_selectedOptions = _IA_cards['WEAPONS'].getOptionsBy(
					[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp)],
					GBL_sort_toolCardOption_by_cost_dsc, _excludeTools);
				break;
			}
		}
	}
}
// -- --------------------------------------------------------------------------------------------------
function GBL_Resolve_POISON(_target_cell) {
	var _selectedOptions = _IA_cards['POISON'].getOptionsBy(
		[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp)],
		GBL_sort_toolCardOption_by_cost_dsc, []);
	var _isExecuted = false;
	var _excludeTools = [];
	var _contract, _currentOption, _tool_id, _contract_options;
	while (count(_selectedOptions) > 0 && !_isExecuted) {
		_currentOption = shift(_selectedOptions);
		for (_tool_id in _currentOption._cast_array) {
			if (_tool_id === CHIP_WIZARDRY || _tool_id === CHIP_STRETCHING) {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.ON_ME,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ALLY_CASTER),
					],
					[]);
			} else {
				_contract = new Contract(
					_tool_id,
					GBL_Contract_types.TARGET,
					[
						GBL_Contract_filters.TARGETS_ONLY(LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON),
						GBL_Contract_filters.EFFECTS_OR([{
							_target_type: LEEK_TYPE_ENEMY,
							_effect_type: EFFECT_POISON,
							_minValue: 0,
							_maxValue: 10000
						}, ]),
					],
					[
						GBL_Contract_sorters.EFFECT_DSC({
							_target_type: LEEK_TYPE_ENEMY | LEEK_TYPE_ENEMY_SUMMON,
							_effect_type: EFFECT_POISON
						}),
						_target_cell !== null ? GBL_Contract_sorters.DIST_CAST_ASC_TO(_target_cell) : GBL_Contract_sorters.TARGET_SAFEST(),
					]);
			}

			_contract_options = FCT_ResolveContractOptions(_contract);
			if (count(_contract_options) > 0) {
				_isExecuted = true;
				shift(_contract_options).use();
			} else {
				_isExecuted = false;
				push(_excludeTools, _tool_id);
				_selectedOptions = _IA_cards['POISON'].getOptionsBy(
					[GBL_filter_toolCardOption_by_cost(myLeek().leek_tp)],
					GBL_sort_toolCardOption_by_cost_dsc, _excludeTools);
				break;
			}
		}
	}
}
// -- --------------------------------------------------------------------------------------------------